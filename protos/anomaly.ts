/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.1
 * source: protos/anomaly.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace solom {
    export class SubscribeRequest extends pb_1.Message {
        #one_of_decls: number[][] = [[4]];
        constructor(data?: any[] | ({
            sol_balance?: SubscribeRequestFilterSolBalance;
            pumpfun?: SubscribeRequestFilterPumpFun;
            transaction?: SubscribeRequestFilterTransactionFilter;
        } & (({
            source?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sol_balance" in data && data.sol_balance != undefined) {
                    this.sol_balance = data.sol_balance;
                }
                if ("pumpfun" in data && data.pumpfun != undefined) {
                    this.pumpfun = data.pumpfun;
                }
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
            }
        }
        get sol_balance() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterSolBalance, 1) as SubscribeRequestFilterSolBalance;
        }
        set sol_balance(value: SubscribeRequestFilterSolBalance) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_sol_balance() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pumpfun() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterPumpFun, 2) as SubscribeRequestFilterPumpFun;
        }
        set pumpfun(value: SubscribeRequestFilterPumpFun) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_pumpfun() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get transaction() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterTransactionFilter, 3) as SubscribeRequestFilterTransactionFilter;
        }
        set transaction(value: SubscribeRequestFilterTransactionFilter) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_transaction() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get source() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set source(value: string) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_source() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _source() {
            const cases: {
                [index: number]: "none" | "source";
            } = {
                0: "none",
                4: "source"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            sol_balance?: ReturnType<typeof SubscribeRequestFilterSolBalance.prototype.toObject>;
            pumpfun?: ReturnType<typeof SubscribeRequestFilterPumpFun.prototype.toObject>;
            transaction?: ReturnType<typeof SubscribeRequestFilterTransactionFilter.prototype.toObject>;
            source?: string;
        }): SubscribeRequest {
            const message = new SubscribeRequest({});
            if (data.sol_balance != null) {
                message.sol_balance = SubscribeRequestFilterSolBalance.fromObject(data.sol_balance);
            }
            if (data.pumpfun != null) {
                message.pumpfun = SubscribeRequestFilterPumpFun.fromObject(data.pumpfun);
            }
            if (data.transaction != null) {
                message.transaction = SubscribeRequestFilterTransactionFilter.fromObject(data.transaction);
            }
            if (data.source != null) {
                message.source = data.source;
            }
            return message;
        }
        toObject() {
            const data: {
                sol_balance?: ReturnType<typeof SubscribeRequestFilterSolBalance.prototype.toObject>;
                pumpfun?: ReturnType<typeof SubscribeRequestFilterPumpFun.prototype.toObject>;
                transaction?: ReturnType<typeof SubscribeRequestFilterTransactionFilter.prototype.toObject>;
                source?: string;
            } = {};
            if (this.sol_balance != null) {
                data.sol_balance = this.sol_balance.toObject();
            }
            if (this.pumpfun != null) {
                data.pumpfun = this.pumpfun.toObject();
            }
            if (this.transaction != null) {
                data.transaction = this.transaction.toObject();
            }
            if (this.source != null) {
                data.source = this.source;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_sol_balance)
                writer.writeMessage(1, this.sol_balance, () => this.sol_balance.serialize(writer));
            if (this.has_pumpfun)
                writer.writeMessage(2, this.pumpfun, () => this.pumpfun.serialize(writer));
            if (this.has_transaction)
                writer.writeMessage(3, this.transaction, () => this.transaction.serialize(writer));
            if (this.has_source)
                writer.writeString(4, this.source);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.sol_balance, () => message.sol_balance = SubscribeRequestFilterSolBalance.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pumpfun, () => message.pumpfun = SubscribeRequestFilterPumpFun.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.transaction, () => message.transaction = SubscribeRequestFilterTransactionFilter.deserialize(reader));
                        break;
                    case 4:
                        message.source = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequest {
            return SubscribeRequest.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterSolBalance extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({} & (({
            min?: number;
        }) | ({
            max?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_min() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_max() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _min() {
            const cases: {
                [index: number]: "none" | "min";
            } = {
                0: "none",
                1: "min"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _max() {
            const cases: {
                [index: number]: "none" | "max";
            } = {
                0: "none",
                2: "max"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            min?: number;
            max?: number;
        }): SubscribeRequestFilterSolBalance {
            const message = new SubscribeRequestFilterSolBalance({});
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                min?: number;
                max?: number;
            } = {};
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_min)
                writer.writeUint64(1, this.min);
            if (this.has_max)
                writer.writeUint64(2, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterSolBalance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterSolBalance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.min = reader.readUint64();
                        break;
                    case 2:
                        message.max = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterSolBalance {
            return SubscribeRequestFilterSolBalance.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterPumpFun extends pb_1.Message {
        #one_of_decls: number[][] = [[1]];
        constructor(data?: any[] | ({} & (({
            is_pumpfun?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("is_pumpfun" in data && data.is_pumpfun != undefined) {
                    this.is_pumpfun = data.is_pumpfun;
                }
            }
        }
        get is_pumpfun() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set is_pumpfun(value: boolean) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_is_pumpfun() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get _is_pumpfun() {
            const cases: {
                [index: number]: "none" | "is_pumpfun";
            } = {
                0: "none",
                1: "is_pumpfun"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            is_pumpfun?: boolean;
        }): SubscribeRequestFilterPumpFun {
            const message = new SubscribeRequestFilterPumpFun({});
            if (data.is_pumpfun != null) {
                message.is_pumpfun = data.is_pumpfun;
            }
            return message;
        }
        toObject() {
            const data: {
                is_pumpfun?: boolean;
            } = {};
            if (this.is_pumpfun != null) {
                data.is_pumpfun = this.is_pumpfun;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_is_pumpfun)
                writer.writeBool(1, this.is_pumpfun);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterPumpFun {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterPumpFun();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.is_pumpfun = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterPumpFun {
            return SubscribeRequestFilterPumpFun.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterTransactionFilter extends pb_1.Message {
        #one_of_decls: number[][] = [[3], [4]];
        constructor(data?: any[] | ({
            mint?: string[];
            signer?: string[];
        } & (({
            min?: number;
        }) | ({
            max?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set mint(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get signer() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set signer(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_min() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
        }
        get has_max() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _min() {
            const cases: {
                [index: number]: "none" | "min";
            } = {
                0: "none",
                3: "min"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _max() {
            const cases: {
                [index: number]: "none" | "max";
            } = {
                0: "none",
                4: "max"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            mint?: string[];
            signer?: string[];
            min?: number;
            max?: number;
        }): SubscribeRequestFilterTransactionFilter {
            const message = new SubscribeRequestFilterTransactionFilter({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string[];
                signer?: string[];
                min?: number;
                max?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeRepeatedString(1, this.mint);
            if (this.signer.length)
                writer.writeRepeatedString(2, this.signer);
            if (this.has_min)
                writer.writeUint64(3, this.min);
            if (this.has_max)
                writer.writeUint64(4, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterTransactionFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterTransactionFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.min = reader.readUint64();
                        break;
                    case 4:
                        message.max = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterTransactionFilter {
            return SubscribeRequestFilterTransactionFilter.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterOHLC extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amm_id?: string;
            time_interval?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
                if ("time_interval" in data && data.time_interval != undefined) {
                    this.time_interval = data.time_interval;
                }
            }
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get time_interval() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set time_interval(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            amm_id?: string;
            time_interval?: number;
        }): SubscribeRequestFilterOHLC {
            const message = new SubscribeRequestFilterOHLC({});
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            if (data.time_interval != null) {
                message.time_interval = data.time_interval;
            }
            return message;
        }
        toObject() {
            const data: {
                amm_id?: string;
                time_interval?: number;
            } = {};
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            if (this.time_interval != null) {
                data.time_interval = this.time_interval;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amm_id.length)
                writer.writeString(1, this.amm_id);
            if (this.time_interval != 0)
                writer.writeInt64(2, this.time_interval);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterOHLC {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterOHLC();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.amm_id = reader.readString();
                        break;
                    case 2:
                        message.time_interval = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterOHLC {
            return SubscribeRequestFilterOHLC.deserialize(bytes);
        }
    }
    export class SubscribeUpdate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            dex?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("dex" in data && data.dex != undefined) {
                    this.dex = data.dex;
                }
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get dex() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set dex(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            dex?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
        }): SubscribeUpdate {
            const message = new SubscribeUpdate({});
            if (data.dex != null) {
                message.dex = data.dex;
            }
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                dex?: string;
                amm_id?: string;
                mint?: string;
                signature?: string;
            } = {};
            if (this.dex != null) {
                data.dex = this.dex;
            }
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.dex.length)
                writer.writeString(1, this.dex);
            if (this.amm_id.length)
                writer.writeString(2, this.amm_id);
            if (this.mint.length)
                writer.writeString(3, this.mint);
            if (this.signature.length)
                writer.writeString(4, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.dex = reader.readString();
                        break;
                    case 2:
                        message.amm_id = reader.readString();
                        break;
                    case 3:
                        message.mint = reader.readString();
                        break;
                    case 4:
                        message.signature = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeUpdate {
            return SubscribeUpdate.deserialize(bytes);
        }
    }
    export class AmmId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amm_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
            }
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            amm_id?: string;
        }): AmmId {
            const message = new AmmId({});
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            return message;
        }
        toObject() {
            const data: {
                amm_id?: string;
            } = {};
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amm_id.length)
                writer.writeString(1, this.amm_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AmmId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AmmId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.amm_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AmmId {
            return AmmId.deserialize(bytes);
        }
    }
    export class Mint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            mint?: string;
        }): Mint {
            const message = new Mint({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Mint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Mint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Mint {
            return Mint.deserialize(bytes);
        }
    }
    export class Boolean extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set value(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: boolean;
        }): Boolean {
            const message = new Boolean({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: boolean;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value != false)
                writer.writeBool(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Boolean {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Boolean();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Boolean {
            return Boolean.deserialize(bytes);
        }
    }
    export class PriceAllWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            price?: Map<number, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("price" in data && data.price != undefined) {
                    this.price = data.price;
                }
            }
            if (!this.price)
                this.price = new Map();
        }
        get price() {
            return pb_1.Message.getField(this, 1) as any as Map<number, number>;
        }
        set price(value: Map<number, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            price?: {
                [key: number]: number;
            };
        }): PriceAllWindow {
            const message = new PriceAllWindow({});
            if (typeof data.price == "object") {
                message.price = new Map(Object.entries(data.price).map(([key, value]) => [Number(key), value]));
            }
            return message;
        }
        toObject() {
            const data: {
                price?: {
                    [key: number]: number;
                };
            } = {};
            if (this.price != null) {
                data.price = (Object.fromEntries)(this.price);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.price) {
                writer.writeMessage(1, this.price, () => {
                    writer.writeInt32(1, key);
                    writer.writeDouble(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PriceAllWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PriceAllWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.price as any, reader, reader.readInt32, reader.readDouble));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PriceAllWindow {
            return PriceAllWindow.deserialize(bytes);
        }
    }
    export class ActionMap extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            volume?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
            }
            if (!this.volume)
                this.volume = new Map();
        }
        get volume() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set volume(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            volume?: {
                [key: string]: number;
            };
        }): ActionMap {
            const message = new ActionMap({});
            if (typeof data.volume == "object") {
                message.volume = new Map(Object.entries(data.volume));
            }
            return message;
        }
        toObject() {
            const data: {
                volume?: {
                    [key: string]: number;
                };
            } = {};
            if (this.volume != null) {
                data.volume = (Object.fromEntries)(this.volume);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.volume) {
                writer.writeMessage(1, this.volume, () => {
                    writer.writeString(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ActionMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ActionMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.volume as any, reader, reader.readString, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ActionMap {
            return ActionMap.deserialize(bytes);
        }
    }
    export class VolumeAllWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            volume?: Map<string, ActionMap>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
            }
            if (!this.volume)
                this.volume = new Map();
        }
        get volume() {
            return pb_1.Message.getField(this, 1) as any as Map<string, ActionMap>;
        }
        set volume(value: Map<string, ActionMap>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            volume?: {
                [key: string]: ReturnType<typeof ActionMap.prototype.toObject>;
            };
        }): VolumeAllWindow {
            const message = new VolumeAllWindow({});
            if (typeof data.volume == "object") {
                message.volume = new Map(Object.entries(data.volume).map(([key, value]) => [key, ActionMap.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                volume?: {
                    [key: string]: ReturnType<typeof ActionMap.prototype.toObject>;
                };
            } = {};
            if (this.volume != null) {
                data.volume = (Object.fromEntries)((Array.from)(this.volume).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.volume) {
                writer.writeMessage(1, this.volume, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VolumeAllWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VolumeAllWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.volume as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = ActionMap.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VolumeAllWindow {
            return VolumeAllWindow.deserialize(bytes);
        }
    }
    export class GetOHLCPriceAllWindowArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
            duration?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            mint?: string;
            duration?: number;
        }): GetOHLCPriceAllWindowArgs {
            const message = new GetOHLCPriceAllWindowArgs({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.duration != null) {
                message.duration = data.duration;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
                duration?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (this.duration != 0)
                writer.writeInt32(2, this.duration);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetOHLCPriceAllWindowArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetOHLCPriceAllWindowArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetOHLCPriceAllWindowArgs {
            return GetOHLCPriceAllWindowArgs.deserialize(bytes);
        }
    }
    export class OHLCPriceAllWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            price?: Map<number, OHLC>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("price" in data && data.price != undefined) {
                    this.price = data.price;
                }
            }
            if (!this.price)
                this.price = new Map();
        }
        get price() {
            return pb_1.Message.getField(this, 1) as any as Map<number, OHLC>;
        }
        set price(value: Map<number, OHLC>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            price?: {
                [key: number]: ReturnType<typeof OHLC.prototype.toObject>;
            };
        }): OHLCPriceAllWindow {
            const message = new OHLCPriceAllWindow({});
            if (typeof data.price == "object") {
                message.price = new Map(Object.entries(data.price).map(([key, value]) => [Number(key), OHLC.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                price?: {
                    [key: number]: ReturnType<typeof OHLC.prototype.toObject>;
                };
            } = {};
            if (this.price != null) {
                data.price = (Object.fromEntries)((Array.from)(this.price).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.price) {
                writer.writeMessage(1, this.price, () => {
                    writer.writeInt64(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OHLCPriceAllWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OHLCPriceAllWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.price as any, reader, reader.readInt64, () => {
                            let value;
                            reader.readMessage(message, () => value = OHLC.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OHLCPriceAllWindow {
            return OHLCPriceAllWindow.deserialize(bytes);
        }
    }
    export class OHLC extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            open?: number;
            high?: number;
            low?: number;
            close?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("open" in data && data.open != undefined) {
                    this.open = data.open;
                }
                if ("high" in data && data.high != undefined) {
                    this.high = data.high;
                }
                if ("low" in data && data.low != undefined) {
                    this.low = data.low;
                }
                if ("close" in data && data.close != undefined) {
                    this.close = data.close;
                }
            }
        }
        get open() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set open(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get high() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set high(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get low() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set low(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get close() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set close(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            open?: number;
            high?: number;
            low?: number;
            close?: number;
        }): OHLC {
            const message = new OHLC({});
            if (data.open != null) {
                message.open = data.open;
            }
            if (data.high != null) {
                message.high = data.high;
            }
            if (data.low != null) {
                message.low = data.low;
            }
            if (data.close != null) {
                message.close = data.close;
            }
            return message;
        }
        toObject() {
            const data: {
                open?: number;
                high?: number;
                low?: number;
                close?: number;
            } = {};
            if (this.open != null) {
                data.open = this.open;
            }
            if (this.high != null) {
                data.high = this.high;
            }
            if (this.low != null) {
                data.low = this.low;
            }
            if (this.close != null) {
                data.close = this.close;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.open != 0)
                writer.writeDouble(1, this.open);
            if (this.high != 0)
                writer.writeDouble(2, this.high);
            if (this.low != 0)
                writer.writeDouble(3, this.low);
            if (this.close != 0)
                writer.writeDouble(4, this.close);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OHLC {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OHLC();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.open = reader.readDouble();
                        break;
                    case 2:
                        message.high = reader.readDouble();
                        break;
                    case 3:
                        message.low = reader.readDouble();
                        break;
                    case 4:
                        message.close = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OHLC {
            return OHLC.deserialize(bytes);
        }
    }
    export class CheckVolumeArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            time_range?: string[];
            action?: string;
            operator?: string;
            value?: number;
            amm_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("time_range" in data && data.time_range != undefined) {
                    this.time_range = data.time_range;
                }
                if ("action" in data && data.action != undefined) {
                    this.action = data.action;
                }
                if ("operator" in data && data.operator != undefined) {
                    this.operator = data.operator;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
            }
        }
        get time_range() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set time_range(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get action() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set action(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get operator() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set operator(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            time_range?: string[];
            action?: string;
            operator?: string;
            value?: number;
            amm_id?: string;
        }): CheckVolumeArgs {
            const message = new CheckVolumeArgs({});
            if (data.time_range != null) {
                message.time_range = data.time_range;
            }
            if (data.action != null) {
                message.action = data.action;
            }
            if (data.operator != null) {
                message.operator = data.operator;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            return message;
        }
        toObject() {
            const data: {
                time_range?: string[];
                action?: string;
                operator?: string;
                value?: number;
                amm_id?: string;
            } = {};
            if (this.time_range != null) {
                data.time_range = this.time_range;
            }
            if (this.action != null) {
                data.action = this.action;
            }
            if (this.operator != null) {
                data.operator = this.operator;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.time_range.length)
                writer.writeRepeatedString(1, this.time_range);
            if (this.action.length)
                writer.writeString(2, this.action);
            if (this.operator.length)
                writer.writeString(3, this.operator);
            if (this.value != 0)
                writer.writeInt64(4, this.value);
            if (this.amm_id.length)
                writer.writeString(5, this.amm_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CheckVolumeArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CheckVolumeArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        message.action = reader.readString();
                        break;
                    case 3:
                        message.operator = reader.readString();
                        break;
                    case 4:
                        message.value = reader.readInt64();
                        break;
                    case 5:
                        message.amm_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CheckVolumeArgs {
            return CheckVolumeArgs.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedAnomalyService {
        static definition = {
            Subscribe: {
                path: "/solom.Anomaly/Subscribe",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: SubscribeRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SubscribeRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SubscribeUpdate) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SubscribeUpdate.deserialize(new Uint8Array(bytes))
            },
            GetPriceAllWindow: {
                path: "/solom.Anomaly/GetPriceAllWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Mint) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Mint.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PriceAllWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PriceAllWindow.deserialize(new Uint8Array(bytes))
            },
            GetVolumeAllWindow: {
                path: "/solom.Anomaly/GetVolumeAllWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: AmmId) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => AmmId.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: VolumeAllWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => VolumeAllWindow.deserialize(new Uint8Array(bytes))
            },
            GetOHLCPriceAllWindow: {
                path: "/solom.Anomaly/GetOHLCPriceAllWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetOHLCPriceAllWindowArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetOHLCPriceAllWindowArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: OHLCPriceAllWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => OHLCPriceAllWindow.deserialize(new Uint8Array(bytes))
            },
            CheckVolume: {
                path: "/solom.Anomaly/CheckVolume",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: CheckVolumeArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => CheckVolumeArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Boolean) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Boolean.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Subscribe(call: grpc_1.ServerDuplexStream<SubscribeRequest, SubscribeUpdate>): void;
        abstract GetPriceAllWindow(call: grpc_1.ServerUnaryCall<Mint, PriceAllWindow>, callback: grpc_1.sendUnaryData<PriceAllWindow>): void;
        abstract GetVolumeAllWindow(call: grpc_1.ServerUnaryCall<AmmId, VolumeAllWindow>, callback: grpc_1.sendUnaryData<VolumeAllWindow>): void;
        abstract GetOHLCPriceAllWindow(call: grpc_1.ServerUnaryCall<GetOHLCPriceAllWindowArgs, OHLCPriceAllWindow>, callback: grpc_1.sendUnaryData<OHLCPriceAllWindow>): void;
        abstract CheckVolume(call: grpc_1.ServerUnaryCall<CheckVolumeArgs, Boolean>, callback: grpc_1.sendUnaryData<Boolean>): void;
    }
    export class AnomalyClient extends grpc_1.makeGenericClientConstructor(UnimplementedAnomalyService.definition, "Anomaly", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        Subscribe: GrpcChunkServiceInterface<SubscribeRequest, SubscribeUpdate> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<SubscribeRequest, SubscribeUpdate> => {
            return super.Subscribe(metadata, options);
        };
        GetPriceAllWindow: GrpcUnaryServiceInterface<Mint, PriceAllWindow> = (message: Mint, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PriceAllWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PriceAllWindow>, callback?: grpc_1.requestCallback<PriceAllWindow>): grpc_1.ClientUnaryCall => {
            return super.GetPriceAllWindow(message, metadata, options, callback);
        };
        GetVolumeAllWindow: GrpcUnaryServiceInterface<AmmId, VolumeAllWindow> = (message: AmmId, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<VolumeAllWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<VolumeAllWindow>, callback?: grpc_1.requestCallback<VolumeAllWindow>): grpc_1.ClientUnaryCall => {
            return super.GetVolumeAllWindow(message, metadata, options, callback);
        };
        GetOHLCPriceAllWindow: GrpcUnaryServiceInterface<GetOHLCPriceAllWindowArgs, OHLCPriceAllWindow> = (message: GetOHLCPriceAllWindowArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<OHLCPriceAllWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<OHLCPriceAllWindow>, callback?: grpc_1.requestCallback<OHLCPriceAllWindow>): grpc_1.ClientUnaryCall => {
            return super.GetOHLCPriceAllWindow(message, metadata, options, callback);
        };
        CheckVolume: GrpcUnaryServiceInterface<CheckVolumeArgs, Boolean> = (message: CheckVolumeArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Boolean>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Boolean>, callback?: grpc_1.requestCallback<Boolean>): grpc_1.ClientUnaryCall => {
            return super.CheckVolume(message, metadata, options, callback);
        };
    }
}
