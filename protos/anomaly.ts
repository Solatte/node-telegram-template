/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.1
 * source: protos/anomaly.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace solom {
    export class SubscribeRequest extends pb_1.Message {
        #one_of_decls: number[][] = [[4]];
        constructor(data?: any[] | ({
            sol_balance?: SubscribeRequestFilterSolBalance;
            pumpfun?: SubscribeRequestFilterPumpFun;
            transaction?: SubscribeRequestFilterTransactionFilter;
        } & (({
            source?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sol_balance" in data && data.sol_balance != undefined) {
                    this.sol_balance = data.sol_balance;
                }
                if ("pumpfun" in data && data.pumpfun != undefined) {
                    this.pumpfun = data.pumpfun;
                }
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
            }
        }
        get sol_balance() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterSolBalance, 1) as SubscribeRequestFilterSolBalance;
        }
        set sol_balance(value: SubscribeRequestFilterSolBalance) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_sol_balance() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pumpfun() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterPumpFun, 2) as SubscribeRequestFilterPumpFun;
        }
        set pumpfun(value: SubscribeRequestFilterPumpFun) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_pumpfun() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get transaction() {
            return pb_1.Message.getWrapperField(this, SubscribeRequestFilterTransactionFilter, 3) as SubscribeRequestFilterTransactionFilter;
        }
        set transaction(value: SubscribeRequestFilterTransactionFilter) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_transaction() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get source() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set source(value: string) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_source() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _source() {
            const cases: {
                [index: number]: "none" | "source";
            } = {
                0: "none",
                4: "source"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            sol_balance?: ReturnType<typeof SubscribeRequestFilterSolBalance.prototype.toObject>;
            pumpfun?: ReturnType<typeof SubscribeRequestFilterPumpFun.prototype.toObject>;
            transaction?: ReturnType<typeof SubscribeRequestFilterTransactionFilter.prototype.toObject>;
            source?: string;
        }): SubscribeRequest {
            const message = new SubscribeRequest({});
            if (data.sol_balance != null) {
                message.sol_balance = SubscribeRequestFilterSolBalance.fromObject(data.sol_balance);
            }
            if (data.pumpfun != null) {
                message.pumpfun = SubscribeRequestFilterPumpFun.fromObject(data.pumpfun);
            }
            if (data.transaction != null) {
                message.transaction = SubscribeRequestFilterTransactionFilter.fromObject(data.transaction);
            }
            if (data.source != null) {
                message.source = data.source;
            }
            return message;
        }
        toObject() {
            const data: {
                sol_balance?: ReturnType<typeof SubscribeRequestFilterSolBalance.prototype.toObject>;
                pumpfun?: ReturnType<typeof SubscribeRequestFilterPumpFun.prototype.toObject>;
                transaction?: ReturnType<typeof SubscribeRequestFilterTransactionFilter.prototype.toObject>;
                source?: string;
            } = {};
            if (this.sol_balance != null) {
                data.sol_balance = this.sol_balance.toObject();
            }
            if (this.pumpfun != null) {
                data.pumpfun = this.pumpfun.toObject();
            }
            if (this.transaction != null) {
                data.transaction = this.transaction.toObject();
            }
            if (this.source != null) {
                data.source = this.source;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_sol_balance)
                writer.writeMessage(1, this.sol_balance, () => this.sol_balance.serialize(writer));
            if (this.has_pumpfun)
                writer.writeMessage(2, this.pumpfun, () => this.pumpfun.serialize(writer));
            if (this.has_transaction)
                writer.writeMessage(3, this.transaction, () => this.transaction.serialize(writer));
            if (this.has_source)
                writer.writeString(4, this.source);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.sol_balance, () => message.sol_balance = SubscribeRequestFilterSolBalance.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pumpfun, () => message.pumpfun = SubscribeRequestFilterPumpFun.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.transaction, () => message.transaction = SubscribeRequestFilterTransactionFilter.deserialize(reader));
                        break;
                    case 4:
                        message.source = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequest {
            return SubscribeRequest.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterSolBalance extends pb_1.Message {
        #one_of_decls: number[][] = [[1], [2]];
        constructor(data?: any[] | ({} & (({
            min?: number;
        }) | ({
            max?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_min() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_max() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _min() {
            const cases: {
                [index: number]: "none" | "min";
            } = {
                0: "none",
                1: "min"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        get _max() {
            const cases: {
                [index: number]: "none" | "max";
            } = {
                0: "none",
                2: "max"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            min?: number;
            max?: number;
        }): SubscribeRequestFilterSolBalance {
            const message = new SubscribeRequestFilterSolBalance({});
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                min?: number;
                max?: number;
            } = {};
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_min)
                writer.writeUint64(1, this.min);
            if (this.has_max)
                writer.writeUint64(2, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterSolBalance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterSolBalance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.min = reader.readUint64();
                        break;
                    case 2:
                        message.max = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterSolBalance {
            return SubscribeRequestFilterSolBalance.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterPumpFun extends pb_1.Message {
        #one_of_decls: number[][] = [[1]];
        constructor(data?: any[] | ({} & (({
            is_pumpfun?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("is_pumpfun" in data && data.is_pumpfun != undefined) {
                    this.is_pumpfun = data.is_pumpfun;
                }
            }
        }
        get is_pumpfun() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set is_pumpfun(value: boolean) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_is_pumpfun() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get _is_pumpfun() {
            const cases: {
                [index: number]: "none" | "is_pumpfun";
            } = {
                0: "none",
                1: "is_pumpfun"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            is_pumpfun?: boolean;
        }): SubscribeRequestFilterPumpFun {
            const message = new SubscribeRequestFilterPumpFun({});
            if (data.is_pumpfun != null) {
                message.is_pumpfun = data.is_pumpfun;
            }
            return message;
        }
        toObject() {
            const data: {
                is_pumpfun?: boolean;
            } = {};
            if (this.is_pumpfun != null) {
                data.is_pumpfun = this.is_pumpfun;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_is_pumpfun)
                writer.writeBool(1, this.is_pumpfun);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterPumpFun {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterPumpFun();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.is_pumpfun = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterPumpFun {
            return SubscribeRequestFilterPumpFun.deserialize(bytes);
        }
    }
    export class SubscribeRequestFilterTransactionFilter extends pb_1.Message {
        #one_of_decls: number[][] = [[3], [4]];
        constructor(data?: any[] | ({
            mint?: string[];
            signer?: string[];
        } & (({
            min?: number;
        }) | ({
            max?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set mint(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get signer() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set signer(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_min() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
        }
        get has_max() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _min() {
            const cases: {
                [index: number]: "none" | "min";
            } = {
                0: "none",
                3: "min"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _max() {
            const cases: {
                [index: number]: "none" | "max";
            } = {
                0: "none",
                4: "max"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            mint?: string[];
            signer?: string[];
            min?: number;
            max?: number;
        }): SubscribeRequestFilterTransactionFilter {
            const message = new SubscribeRequestFilterTransactionFilter({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string[];
                signer?: string[];
                min?: number;
                max?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeRepeatedString(1, this.mint);
            if (this.signer.length)
                writer.writeRepeatedString(2, this.signer);
            if (this.has_min)
                writer.writeUint64(3, this.min);
            if (this.has_max)
                writer.writeUint64(4, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRequestFilterTransactionFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRequestFilterTransactionFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.min = reader.readUint64();
                        break;
                    case 4:
                        message.max = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRequestFilterTransactionFilter {
            return SubscribeRequestFilterTransactionFilter.deserialize(bytes);
        }
    }
    export class SubscribeUpdate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            source?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
            lp_balance_in_sol?: number;
            signer?: string;
            action?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("lp_balance_in_sol" in data && data.lp_balance_in_sol != undefined) {
                    this.lp_balance_in_sol = data.lp_balance_in_sol;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
                if ("action" in data && data.action != undefined) {
                    this.action = data.action;
                }
            }
        }
        get source() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set source(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get lp_balance_in_sol() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set lp_balance_in_sol(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get signer() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get action() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set action(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            source?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
            lp_balance_in_sol?: number;
            signer?: string;
            action?: number;
        }): SubscribeUpdate {
            const message = new SubscribeUpdate({});
            if (data.source != null) {
                message.source = data.source;
            }
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.lp_balance_in_sol != null) {
                message.lp_balance_in_sol = data.lp_balance_in_sol;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            if (data.action != null) {
                message.action = data.action;
            }
            return message;
        }
        toObject() {
            const data: {
                source?: string;
                amm_id?: string;
                mint?: string;
                signature?: string;
                lp_balance_in_sol?: number;
                signer?: string;
                action?: number;
            } = {};
            if (this.source != null) {
                data.source = this.source;
            }
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.lp_balance_in_sol != null) {
                data.lp_balance_in_sol = this.lp_balance_in_sol;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            if (this.action != null) {
                data.action = this.action;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.source.length)
                writer.writeString(1, this.source);
            if (this.amm_id.length)
                writer.writeString(2, this.amm_id);
            if (this.mint.length)
                writer.writeString(3, this.mint);
            if (this.signature.length)
                writer.writeString(4, this.signature);
            if (this.lp_balance_in_sol != 0)
                writer.writeUint64(5, this.lp_balance_in_sol);
            if (this.signer.length)
                writer.writeString(6, this.signer);
            if (this.action != 0)
                writer.writeUint64(7, this.action);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.source = reader.readString();
                        break;
                    case 2:
                        message.amm_id = reader.readString();
                        break;
                    case 3:
                        message.mint = reader.readString();
                        break;
                    case 4:
                        message.signature = reader.readString();
                        break;
                    case 5:
                        message.lp_balance_in_sol = reader.readUint64();
                        break;
                    case 6:
                        message.signer = reader.readString();
                        break;
                    case 7:
                        message.action = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeUpdate {
            return SubscribeUpdate.deserialize(bytes);
        }
    }
    export class SubscribeEventRequest extends pb_1.Message {
        #one_of_decls: number[][] = [[1]];
        constructor(data?: any[] | ({} & (({
            source?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
            }
        }
        get source() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set source(value: string) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_source() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get _source() {
            const cases: {
                [index: number]: "none" | "source";
            } = {
                0: "none",
                1: "source"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            source?: string;
        }): SubscribeEventRequest {
            const message = new SubscribeEventRequest({});
            if (data.source != null) {
                message.source = data.source;
            }
            return message;
        }
        toObject() {
            const data: {
                source?: string;
            } = {};
            if (this.source != null) {
                data.source = this.source;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_source)
                writer.writeString(1, this.source);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeEventRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeEventRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.source = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeEventRequest {
            return SubscribeEventRequest.deserialize(bytes);
        }
    }
    export class SubscribeEventUpdate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            source?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
            event?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("source" in data && data.source != undefined) {
                    this.source = data.source;
                }
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("event" in data && data.event != undefined) {
                    this.event = data.event;
                }
            }
        }
        get source() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set source(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get event() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set event(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            source?: string;
            amm_id?: string;
            mint?: string;
            signature?: string;
            event?: string;
        }): SubscribeEventUpdate {
            const message = new SubscribeEventUpdate({});
            if (data.source != null) {
                message.source = data.source;
            }
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.event != null) {
                message.event = data.event;
            }
            return message;
        }
        toObject() {
            const data: {
                source?: string;
                amm_id?: string;
                mint?: string;
                signature?: string;
                event?: string;
            } = {};
            if (this.source != null) {
                data.source = this.source;
            }
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.event != null) {
                data.event = this.event;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.source.length)
                writer.writeString(1, this.source);
            if (this.amm_id.length)
                writer.writeString(2, this.amm_id);
            if (this.mint.length)
                writer.writeString(3, this.mint);
            if (this.signature.length)
                writer.writeString(4, this.signature);
            if (this.event.length)
                writer.writeString(5, this.event);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeEventUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeEventUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.source = reader.readString();
                        break;
                    case 2:
                        message.amm_id = reader.readString();
                        break;
                    case 3:
                        message.mint = reader.readString();
                        break;
                    case 4:
                        message.signature = reader.readString();
                        break;
                    case 5:
                        message.event = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeEventUpdate {
            return SubscribeEventUpdate.deserialize(bytes);
        }
    }
    export class SubscribeGeyserRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            is_listening?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("is_listening" in data && data.is_listening != undefined) {
                    this.is_listening = data.is_listening;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get is_listening() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set is_listening(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            is_listening?: boolean;
        }): SubscribeGeyserRequest {
            const message = new SubscribeGeyserRequest({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.is_listening != null) {
                message.is_listening = data.is_listening;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                is_listening?: boolean;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.is_listening != null) {
                data.is_listening = this.is_listening;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.is_listening != false)
                writer.writeBool(2, this.is_listening);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeGeyserRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeGeyserRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.is_listening = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeGeyserRequest {
            return SubscribeGeyserRequest.deserialize(bytes);
        }
    }
    export class SubscribeGeyserUpdate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            is_listening?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("is_listening" in data && data.is_listening != undefined) {
                    this.is_listening = data.is_listening;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get is_listening() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set is_listening(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            is_listening?: boolean;
        }): SubscribeGeyserUpdate {
            const message = new SubscribeGeyserUpdate({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.is_listening != null) {
                message.is_listening = data.is_listening;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                is_listening?: boolean;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.is_listening != null) {
                data.is_listening = this.is_listening;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.is_listening != false)
                writer.writeBool(2, this.is_listening);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeGeyserUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeGeyserUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.is_listening = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeGeyserUpdate {
            return SubscribeGeyserUpdate.deserialize(bytes);
        }
    }
    export class AmmId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amm_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
            }
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            amm_id?: string;
        }): AmmId {
            const message = new AmmId({});
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            return message;
        }
        toObject() {
            const data: {
                amm_id?: string;
            } = {};
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amm_id.length)
                writer.writeString(1, this.amm_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AmmId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AmmId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.amm_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AmmId {
            return AmmId.deserialize(bytes);
        }
    }
    export class Mint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            mint?: string;
        }): Mint {
            const message = new Mint({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Mint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Mint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Mint {
            return Mint.deserialize(bytes);
        }
    }
    export class Boolean extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set value(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: boolean;
        }): Boolean {
            const message = new Boolean({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: boolean;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value != false)
                writer.writeBool(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Boolean {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Boolean();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Boolean {
            return Boolean.deserialize(bytes);
        }
    }
    export class PriceAllWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            price?: Map<number, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("price" in data && data.price != undefined) {
                    this.price = data.price;
                }
            }
            if (!this.price)
                this.price = new Map();
        }
        get price() {
            return pb_1.Message.getField(this, 1) as any as Map<number, number>;
        }
        set price(value: Map<number, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            price?: {
                [key: number]: number;
            };
        }): PriceAllWindow {
            const message = new PriceAllWindow({});
            if (typeof data.price == "object") {
                message.price = new Map(Object.entries(data.price).map(([key, value]) => [Number(key), value]));
            }
            return message;
        }
        toObject() {
            const data: {
                price?: {
                    [key: number]: number;
                };
            } = {};
            if (this.price != null) {
                data.price = (Object.fromEntries)(this.price);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.price) {
                writer.writeMessage(1, this.price, () => {
                    writer.writeInt32(1, key);
                    writer.writeDouble(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PriceAllWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PriceAllWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.price as any, reader, reader.readInt32, reader.readDouble));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PriceAllWindow {
            return PriceAllWindow.deserialize(bytes);
        }
    }
    export class GetOneMinuteVolumeByWindowArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
            duration?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            mint?: string;
            duration?: number;
        }): GetOneMinuteVolumeByWindowArgs {
            const message = new GetOneMinuteVolumeByWindowArgs({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.duration != null) {
                message.duration = data.duration;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
                duration?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (this.duration != 0)
                writer.writeInt32(2, this.duration);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetOneMinuteVolumeByWindowArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetOneMinuteVolumeByWindowArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetOneMinuteVolumeByWindowArgs {
            return GetOneMinuteVolumeByWindowArgs.deserialize(bytes);
        }
    }
    export class ActionMap extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            volume?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
            }
            if (!this.volume)
                this.volume = new Map();
        }
        get volume() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set volume(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            volume?: {
                [key: string]: number;
            };
        }): ActionMap {
            const message = new ActionMap({});
            if (typeof data.volume == "object") {
                message.volume = new Map(Object.entries(data.volume));
            }
            return message;
        }
        toObject() {
            const data: {
                volume?: {
                    [key: string]: number;
                };
            } = {};
            if (this.volume != null) {
                data.volume = (Object.fromEntries)(this.volume);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.volume) {
                writer.writeMessage(1, this.volume, () => {
                    writer.writeString(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ActionMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ActionMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.volume as any, reader, reader.readString, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ActionMap {
            return ActionMap.deserialize(bytes);
        }
    }
    export class OneMinuteVolumeByWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            volume?: Map<number, ActionMap>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("volume" in data && data.volume != undefined) {
                    this.volume = data.volume;
                }
            }
            if (!this.volume)
                this.volume = new Map();
        }
        get volume() {
            return pb_1.Message.getField(this, 1) as any as Map<number, ActionMap>;
        }
        set volume(value: Map<number, ActionMap>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            volume?: {
                [key: number]: ReturnType<typeof ActionMap.prototype.toObject>;
            };
        }): OneMinuteVolumeByWindow {
            const message = new OneMinuteVolumeByWindow({});
            if (typeof data.volume == "object") {
                message.volume = new Map(Object.entries(data.volume).map(([key, value]) => [Number(key), ActionMap.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                volume?: {
                    [key: number]: ReturnType<typeof ActionMap.prototype.toObject>;
                };
            } = {};
            if (this.volume != null) {
                data.volume = (Object.fromEntries)((Array.from)(this.volume).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.volume) {
                writer.writeMessage(1, this.volume, () => {
                    writer.writeInt32(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneMinuteVolumeByWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneMinuteVolumeByWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.volume as any, reader, reader.readInt32, () => {
                            let value;
                            reader.readMessage(message, () => value = ActionMap.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OneMinuteVolumeByWindow {
            return OneMinuteVolumeByWindow.deserialize(bytes);
        }
    }
    export class GetOHLCPriceAllWindowArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
            duration?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            mint?: string;
            duration?: number;
        }): GetOHLCPriceAllWindowArgs {
            const message = new GetOHLCPriceAllWindowArgs({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.duration != null) {
                message.duration = data.duration;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
                duration?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (this.duration != 0)
                writer.writeInt32(2, this.duration);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetOHLCPriceAllWindowArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetOHLCPriceAllWindowArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetOHLCPriceAllWindowArgs {
            return GetOHLCPriceAllWindowArgs.deserialize(bytes);
        }
    }
    export class OHLCPriceAllWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            price?: Map<number, OHLC>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("price" in data && data.price != undefined) {
                    this.price = data.price;
                }
            }
            if (!this.price)
                this.price = new Map();
        }
        get price() {
            return pb_1.Message.getField(this, 1) as any as Map<number, OHLC>;
        }
        set price(value: Map<number, OHLC>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            price?: {
                [key: number]: ReturnType<typeof OHLC.prototype.toObject>;
            };
        }): OHLCPriceAllWindow {
            const message = new OHLCPriceAllWindow({});
            if (typeof data.price == "object") {
                message.price = new Map(Object.entries(data.price).map(([key, value]) => [Number(key), OHLC.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                price?: {
                    [key: number]: ReturnType<typeof OHLC.prototype.toObject>;
                };
            } = {};
            if (this.price != null) {
                data.price = (Object.fromEntries)((Array.from)(this.price).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.price) {
                writer.writeMessage(1, this.price, () => {
                    writer.writeInt64(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OHLCPriceAllWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OHLCPriceAllWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.price as any, reader, reader.readInt64, () => {
                            let value;
                            reader.readMessage(message, () => value = OHLC.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OHLCPriceAllWindow {
            return OHLCPriceAllWindow.deserialize(bytes);
        }
    }
    export class OHLC extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            open?: number;
            high?: number;
            low?: number;
            close?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("open" in data && data.open != undefined) {
                    this.open = data.open;
                }
                if ("high" in data && data.high != undefined) {
                    this.high = data.high;
                }
                if ("low" in data && data.low != undefined) {
                    this.low = data.low;
                }
                if ("close" in data && data.close != undefined) {
                    this.close = data.close;
                }
            }
        }
        get open() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set open(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get high() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set high(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get low() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set low(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get close() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set close(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            open?: number;
            high?: number;
            low?: number;
            close?: number;
        }): OHLC {
            const message = new OHLC({});
            if (data.open != null) {
                message.open = data.open;
            }
            if (data.high != null) {
                message.high = data.high;
            }
            if (data.low != null) {
                message.low = data.low;
            }
            if (data.close != null) {
                message.close = data.close;
            }
            return message;
        }
        toObject() {
            const data: {
                open?: number;
                high?: number;
                low?: number;
                close?: number;
            } = {};
            if (this.open != null) {
                data.open = this.open;
            }
            if (this.high != null) {
                data.high = this.high;
            }
            if (this.low != null) {
                data.low = this.low;
            }
            if (this.close != null) {
                data.close = this.close;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.open != 0)
                writer.writeDouble(1, this.open);
            if (this.high != 0)
                writer.writeDouble(2, this.high);
            if (this.low != 0)
                writer.writeDouble(3, this.low);
            if (this.close != 0)
                writer.writeDouble(4, this.close);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OHLC {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OHLC();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.open = reader.readDouble();
                        break;
                    case 2:
                        message.high = reader.readDouble();
                        break;
                    case 3:
                        message.low = reader.readDouble();
                        break;
                    case 4:
                        message.close = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OHLC {
            return OHLC.deserialize(bytes);
        }
    }
    export class IsAmmGoodArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            time_range?: string[];
            action?: string;
            operator?: string;
            value?: number;
            amm_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("time_range" in data && data.time_range != undefined) {
                    this.time_range = data.time_range;
                }
                if ("action" in data && data.action != undefined) {
                    this.action = data.action;
                }
                if ("operator" in data && data.operator != undefined) {
                    this.operator = data.operator;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("amm_id" in data && data.amm_id != undefined) {
                    this.amm_id = data.amm_id;
                }
            }
        }
        get time_range() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set time_range(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get action() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set action(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get operator() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set operator(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get amm_id() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set amm_id(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            time_range?: string[];
            action?: string;
            operator?: string;
            value?: number;
            amm_id?: string;
        }): IsAmmGoodArgs {
            const message = new IsAmmGoodArgs({});
            if (data.time_range != null) {
                message.time_range = data.time_range;
            }
            if (data.action != null) {
                message.action = data.action;
            }
            if (data.operator != null) {
                message.operator = data.operator;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.amm_id != null) {
                message.amm_id = data.amm_id;
            }
            return message;
        }
        toObject() {
            const data: {
                time_range?: string[];
                action?: string;
                operator?: string;
                value?: number;
                amm_id?: string;
            } = {};
            if (this.time_range != null) {
                data.time_range = this.time_range;
            }
            if (this.action != null) {
                data.action = this.action;
            }
            if (this.operator != null) {
                data.operator = this.operator;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.amm_id != null) {
                data.amm_id = this.amm_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.time_range.length)
                writer.writeRepeatedString(1, this.time_range);
            if (this.action.length)
                writer.writeString(2, this.action);
            if (this.operator.length)
                writer.writeString(3, this.operator);
            if (this.value != 0)
                writer.writeInt64(4, this.value);
            if (this.amm_id.length)
                writer.writeString(5, this.amm_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsAmmGoodArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsAmmGoodArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        message.action = reader.readString();
                        break;
                    case 3:
                        message.operator = reader.readString();
                        break;
                    case 4:
                        message.value = reader.readInt64();
                        break;
                    case 5:
                        message.amm_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IsAmmGoodArgs {
            return IsAmmGoodArgs.deserialize(bytes);
        }
    }
    export class GetTokenByArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            start_time?: number;
            end_time?: number;
            count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("start_time" in data && data.start_time != undefined) {
                    this.start_time = data.start_time;
                }
                if ("end_time" in data && data.end_time != undefined) {
                    this.end_time = data.end_time;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
            }
        }
        get start_time() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set start_time(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get end_time() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set end_time(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            start_time?: number;
            end_time?: number;
            count?: number;
        }): GetTokenByArgs {
            const message = new GetTokenByArgs({});
            if (data.start_time != null) {
                message.start_time = data.start_time;
            }
            if (data.end_time != null) {
                message.end_time = data.end_time;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            return message;
        }
        toObject() {
            const data: {
                start_time?: number;
                end_time?: number;
                count?: number;
            } = {};
            if (this.start_time != null) {
                data.start_time = this.start_time;
            }
            if (this.end_time != null) {
                data.end_time = this.end_time;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.start_time != 0)
                writer.writeInt64(1, this.start_time);
            if (this.end_time != 0)
                writer.writeInt64(2, this.end_time);
            if (this.count != 0)
                writer.writeInt64(3, this.count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetTokenByArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetTokenByArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.start_time = reader.readInt64();
                        break;
                    case 2:
                        message.end_time = reader.readInt64();
                        break;
                    case 3:
                        message.count = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetTokenByArgs {
            return GetTokenByArgs.deserialize(bytes);
        }
    }
    export class TokenBy extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tokens?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tokens" in data && data.tokens != undefined) {
                    this.tokens = data.tokens;
                }
            }
        }
        get tokens() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set tokens(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            tokens?: string[];
        }): TokenBy {
            const message = new TokenBy({});
            if (data.tokens != null) {
                message.tokens = data.tokens;
            }
            return message;
        }
        toObject() {
            const data: {
                tokens?: string[];
            } = {};
            if (this.tokens != null) {
                data.tokens = this.tokens;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tokens.length)
                writer.writeRepeatedString(1, this.tokens);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TokenBy {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TokenBy();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TokenBy {
            return TokenBy.deserialize(bytes);
        }
    }
    export class GetWhaleCountByWindowArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
            duration?: number;
            min?: number;
            max?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            mint?: string;
            duration?: number;
            min?: number;
            max?: number;
        }): GetWhaleCountByWindowArgs {
            const message = new GetWhaleCountByWindowArgs({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.duration != null) {
                message.duration = data.duration;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.max != null) {
                message.max = data.max;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
                duration?: number;
                min?: number;
                max?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.max != null) {
                data.max = this.max;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (this.duration != 0)
                writer.writeInt32(2, this.duration);
            if (this.min != 0)
                writer.writeInt64(3, this.min);
            if (this.max != 0)
                writer.writeInt64(4, this.max);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetWhaleCountByWindowArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetWhaleCountByWindowArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt32();
                        break;
                    case 3:
                        message.min = reader.readInt64();
                        break;
                    case 4:
                        message.max = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetWhaleCountByWindowArgs {
            return GetWhaleCountByWindowArgs.deserialize(bytes);
        }
    }
    export class CountMap extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            direction?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("direction" in data && data.direction != undefined) {
                    this.direction = data.direction;
                }
            }
            if (!this.direction)
                this.direction = new Map();
        }
        get direction() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set direction(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            direction?: {
                [key: string]: number;
            };
        }): CountMap {
            const message = new CountMap({});
            if (typeof data.direction == "object") {
                message.direction = new Map(Object.entries(data.direction));
            }
            return message;
        }
        toObject() {
            const data: {
                direction?: {
                    [key: string]: number;
                };
            } = {};
            if (this.direction != null) {
                data.direction = (Object.fromEntries)(this.direction);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.direction) {
                writer.writeMessage(1, this.direction, () => {
                    writer.writeString(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CountMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CountMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.direction as any, reader, reader.readString, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CountMap {
            return CountMap.deserialize(bytes);
        }
    }
    export class WhaleCountByWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            window?: Map<number, CountMap>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("window" in data && data.window != undefined) {
                    this.window = data.window;
                }
            }
            if (!this.window)
                this.window = new Map();
        }
        get window() {
            return pb_1.Message.getField(this, 1) as any as Map<number, CountMap>;
        }
        set window(value: Map<number, CountMap>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            window?: {
                [key: number]: ReturnType<typeof CountMap.prototype.toObject>;
            };
        }): WhaleCountByWindow {
            const message = new WhaleCountByWindow({});
            if (typeof data.window == "object") {
                message.window = new Map(Object.entries(data.window).map(([key, value]) => [Number(key), CountMap.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                window?: {
                    [key: number]: ReturnType<typeof CountMap.prototype.toObject>;
                };
            } = {};
            if (this.window != null) {
                data.window = (Object.fromEntries)((Array.from)(this.window).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.window) {
                writer.writeMessage(1, this.window, () => {
                    writer.writeInt32(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WhaleCountByWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WhaleCountByWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.window as any, reader, reader.readInt32, () => {
                            let value;
                            reader.readMessage(message, () => value = CountMap.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WhaleCountByWindow {
            return WhaleCountByWindow.deserialize(bytes);
        }
    }
    export class GetOneMinuteTradeSizeByWindowArgs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mint?: string;
            duration?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
            }
        }
        get mint() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set mint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            mint?: string;
            duration?: number;
        }): GetOneMinuteTradeSizeByWindowArgs {
            const message = new GetOneMinuteTradeSizeByWindowArgs({});
            if (data.mint != null) {
                message.mint = data.mint;
            }
            if (data.duration != null) {
                message.duration = data.duration;
            }
            return message;
        }
        toObject() {
            const data: {
                mint?: string;
                duration?: number;
            } = {};
            if (this.mint != null) {
                data.mint = this.mint;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mint.length)
                writer.writeString(1, this.mint);
            if (this.duration != 0)
                writer.writeInt32(2, this.duration);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetOneMinuteTradeSizeByWindowArgs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetOneMinuteTradeSizeByWindowArgs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mint = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetOneMinuteTradeSizeByWindowArgs {
            return GetOneMinuteTradeSizeByWindowArgs.deserialize(bytes);
        }
    }
    export class SizeMap extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            category?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("category" in data && data.category != undefined) {
                    this.category = data.category;
                }
            }
            if (!this.category)
                this.category = new Map();
        }
        get category() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set category(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            category?: {
                [key: string]: number;
            };
        }): SizeMap {
            const message = new SizeMap({});
            if (typeof data.category == "object") {
                message.category = new Map(Object.entries(data.category));
            }
            return message;
        }
        toObject() {
            const data: {
                category?: {
                    [key: string]: number;
                };
            } = {};
            if (this.category != null) {
                data.category = (Object.fromEntries)(this.category);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.category) {
                writer.writeMessage(1, this.category, () => {
                    writer.writeString(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SizeMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SizeMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.category as any, reader, reader.readString, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SizeMap {
            return SizeMap.deserialize(bytes);
        }
    }
    export class CategoryMap extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            direction?: Map<string, SizeMap>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("direction" in data && data.direction != undefined) {
                    this.direction = data.direction;
                }
            }
            if (!this.direction)
                this.direction = new Map();
        }
        get direction() {
            return pb_1.Message.getField(this, 1) as any as Map<string, SizeMap>;
        }
        set direction(value: Map<string, SizeMap>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            direction?: {
                [key: string]: ReturnType<typeof SizeMap.prototype.toObject>;
            };
        }): CategoryMap {
            const message = new CategoryMap({});
            if (typeof data.direction == "object") {
                message.direction = new Map(Object.entries(data.direction).map(([key, value]) => [key, SizeMap.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                direction?: {
                    [key: string]: ReturnType<typeof SizeMap.prototype.toObject>;
                };
            } = {};
            if (this.direction != null) {
                data.direction = (Object.fromEntries)((Array.from)(this.direction).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.direction) {
                writer.writeMessage(1, this.direction, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CategoryMap {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CategoryMap();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.direction as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = SizeMap.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CategoryMap {
            return CategoryMap.deserialize(bytes);
        }
    }
    export class OneMinuteTradeSizeByWindow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            window?: Map<number, CategoryMap>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("window" in data && data.window != undefined) {
                    this.window = data.window;
                }
            }
            if (!this.window)
                this.window = new Map();
        }
        get window() {
            return pb_1.Message.getField(this, 1) as any as Map<number, CategoryMap>;
        }
        set window(value: Map<number, CategoryMap>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            window?: {
                [key: number]: ReturnType<typeof CategoryMap.prototype.toObject>;
            };
        }): OneMinuteTradeSizeByWindow {
            const message = new OneMinuteTradeSizeByWindow({});
            if (typeof data.window == "object") {
                message.window = new Map(Object.entries(data.window).map(([key, value]) => [Number(key), CategoryMap.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                window?: {
                    [key: number]: ReturnType<typeof CategoryMap.prototype.toObject>;
                };
            } = {};
            if (this.window != null) {
                data.window = (Object.fromEntries)((Array.from)(this.window).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.window) {
                writer.writeMessage(1, this.window, () => {
                    writer.writeInt32(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneMinuteTradeSizeByWindow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneMinuteTradeSizeByWindow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.window as any, reader, reader.readInt32, () => {
                            let value;
                            reader.readMessage(message, () => value = CategoryMap.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OneMinuteTradeSizeByWindow {
            return OneMinuteTradeSizeByWindow.deserialize(bytes);
        }
    }
    export class Connect extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            active?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("active" in data && data.active != undefined) {
                    this.active = data.active;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get active() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set active(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            active?: boolean;
        }): Connect {
            const message = new Connect({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.active != null) {
                message.active = data.active;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                active?: boolean;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.active != null) {
                data.active = this.active;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.active != false)
                writer.writeBool(2, this.active);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Connect {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Connect();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.active = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Connect {
            return Connect.deserialize(bytes);
        }
    }
    export class Close extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): Close {
            const message = new Close({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Close {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Close();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Close {
            return Close.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedAnomalyService {
        static definition = {
            Subscribe: {
                path: "/solom.Anomaly/Subscribe",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: SubscribeRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SubscribeRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SubscribeUpdate) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SubscribeUpdate.deserialize(new Uint8Array(bytes))
            },
            SubscribeEvent: {
                path: "/solom.Anomaly/SubscribeEvent",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: SubscribeEventRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SubscribeEventRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SubscribeEventUpdate) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SubscribeEventUpdate.deserialize(new Uint8Array(bytes))
            },
            SubscribeGeyser: {
                path: "/solom.Anomaly/SubscribeGeyser",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: SubscribeGeyserRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SubscribeGeyserRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SubscribeGeyserUpdate) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SubscribeGeyserUpdate.deserialize(new Uint8Array(bytes))
            },
            GetPriceAllWindow: {
                path: "/solom.Anomaly/GetPriceAllWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Mint) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Mint.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PriceAllWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PriceAllWindow.deserialize(new Uint8Array(bytes))
            },
            GetOneMinuteVolumeByWindow: {
                path: "/solom.Anomaly/GetOneMinuteVolumeByWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetOneMinuteVolumeByWindowArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetOneMinuteVolumeByWindowArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: OneMinuteVolumeByWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => OneMinuteVolumeByWindow.deserialize(new Uint8Array(bytes))
            },
            GetOHLCPriceAllWindow: {
                path: "/solom.Anomaly/GetOHLCPriceAllWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetOHLCPriceAllWindowArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetOHLCPriceAllWindowArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: OHLCPriceAllWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => OHLCPriceAllWindow.deserialize(new Uint8Array(bytes))
            },
            IsAmmGood: {
                path: "/solom.Anomaly/IsAmmGood",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: IsAmmGoodArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => IsAmmGoodArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Boolean) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Boolean.deserialize(new Uint8Array(bytes))
            },
            GetMostActiveToken: {
                path: "/solom.Anomaly/GetMostActiveToken",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetTokenByArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetTokenByArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: TokenBy) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => TokenBy.deserialize(new Uint8Array(bytes))
            },
            GetTokenByTrending: {
                path: "/solom.Anomaly/GetTokenByTrending",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetTokenByArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetTokenByArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: TokenBy) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => TokenBy.deserialize(new Uint8Array(bytes))
            },
            GetTokenByBuy: {
                path: "/solom.Anomaly/GetTokenByBuy",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetTokenByArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetTokenByArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: TokenBy) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => TokenBy.deserialize(new Uint8Array(bytes))
            },
            GetTokenBySell: {
                path: "/solom.Anomaly/GetTokenBySell",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetTokenByArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetTokenByArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: TokenBy) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => TokenBy.deserialize(new Uint8Array(bytes))
            },
            GetWhaleCountByWindow: {
                path: "/solom.Anomaly/GetWhaleCountByWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetWhaleCountByWindowArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetWhaleCountByWindowArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: WhaleCountByWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => WhaleCountByWindow.deserialize(new Uint8Array(bytes))
            },
            GetOneMinuteTradeSizeByWindow: {
                path: "/solom.Anomaly/GetOneMinuteTradeSizeByWindow",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetOneMinuteTradeSizeByWindowArgs) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetOneMinuteTradeSizeByWindowArgs.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: OneMinuteTradeSizeByWindow) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => OneMinuteTradeSizeByWindow.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Subscribe(call: grpc_1.ServerDuplexStream<SubscribeRequest, SubscribeUpdate>): void;
        abstract SubscribeEvent(call: grpc_1.ServerDuplexStream<SubscribeEventRequest, SubscribeEventUpdate>): void;
        abstract SubscribeGeyser(call: grpc_1.ServerDuplexStream<SubscribeGeyserRequest, SubscribeGeyserUpdate>): void;
        abstract GetPriceAllWindow(call: grpc_1.ServerUnaryCall<Mint, PriceAllWindow>, callback: grpc_1.sendUnaryData<PriceAllWindow>): void;
        abstract GetOneMinuteVolumeByWindow(call: grpc_1.ServerUnaryCall<GetOneMinuteVolumeByWindowArgs, OneMinuteVolumeByWindow>, callback: grpc_1.sendUnaryData<OneMinuteVolumeByWindow>): void;
        abstract GetOHLCPriceAllWindow(call: grpc_1.ServerUnaryCall<GetOHLCPriceAllWindowArgs, OHLCPriceAllWindow>, callback: grpc_1.sendUnaryData<OHLCPriceAllWindow>): void;
        abstract IsAmmGood(call: grpc_1.ServerUnaryCall<IsAmmGoodArgs, Boolean>, callback: grpc_1.sendUnaryData<Boolean>): void;
        abstract GetMostActiveToken(call: grpc_1.ServerUnaryCall<GetTokenByArgs, TokenBy>, callback: grpc_1.sendUnaryData<TokenBy>): void;
        abstract GetTokenByTrending(call: grpc_1.ServerUnaryCall<GetTokenByArgs, TokenBy>, callback: grpc_1.sendUnaryData<TokenBy>): void;
        abstract GetTokenByBuy(call: grpc_1.ServerUnaryCall<GetTokenByArgs, TokenBy>, callback: grpc_1.sendUnaryData<TokenBy>): void;
        abstract GetTokenBySell(call: grpc_1.ServerUnaryCall<GetTokenByArgs, TokenBy>, callback: grpc_1.sendUnaryData<TokenBy>): void;
        abstract GetWhaleCountByWindow(call: grpc_1.ServerUnaryCall<GetWhaleCountByWindowArgs, WhaleCountByWindow>, callback: grpc_1.sendUnaryData<WhaleCountByWindow>): void;
        abstract GetOneMinuteTradeSizeByWindow(call: grpc_1.ServerUnaryCall<GetOneMinuteTradeSizeByWindowArgs, OneMinuteTradeSizeByWindow>, callback: grpc_1.sendUnaryData<OneMinuteTradeSizeByWindow>): void;
    }
    export class AnomalyClient extends grpc_1.makeGenericClientConstructor(UnimplementedAnomalyService.definition, "Anomaly", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        Subscribe: GrpcChunkServiceInterface<SubscribeRequest, SubscribeUpdate> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<SubscribeRequest, SubscribeUpdate> => {
            return super.Subscribe(metadata, options);
        };
        SubscribeEvent: GrpcChunkServiceInterface<SubscribeEventRequest, SubscribeEventUpdate> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<SubscribeEventRequest, SubscribeEventUpdate> => {
            return super.SubscribeEvent(metadata, options);
        };
        SubscribeGeyser: GrpcChunkServiceInterface<SubscribeGeyserRequest, SubscribeGeyserUpdate> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<SubscribeGeyserRequest, SubscribeGeyserUpdate> => {
            return super.SubscribeGeyser(metadata, options);
        };
        GetPriceAllWindow: GrpcUnaryServiceInterface<Mint, PriceAllWindow> = (message: Mint, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PriceAllWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PriceAllWindow>, callback?: grpc_1.requestCallback<PriceAllWindow>): grpc_1.ClientUnaryCall => {
            return super.GetPriceAllWindow(message, metadata, options, callback);
        };
        GetOneMinuteVolumeByWindow: GrpcUnaryServiceInterface<GetOneMinuteVolumeByWindowArgs, OneMinuteVolumeByWindow> = (message: GetOneMinuteVolumeByWindowArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<OneMinuteVolumeByWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<OneMinuteVolumeByWindow>, callback?: grpc_1.requestCallback<OneMinuteVolumeByWindow>): grpc_1.ClientUnaryCall => {
            return super.GetOneMinuteVolumeByWindow(message, metadata, options, callback);
        };
        GetOHLCPriceAllWindow: GrpcUnaryServiceInterface<GetOHLCPriceAllWindowArgs, OHLCPriceAllWindow> = (message: GetOHLCPriceAllWindowArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<OHLCPriceAllWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<OHLCPriceAllWindow>, callback?: grpc_1.requestCallback<OHLCPriceAllWindow>): grpc_1.ClientUnaryCall => {
            return super.GetOHLCPriceAllWindow(message, metadata, options, callback);
        };
        IsAmmGood: GrpcUnaryServiceInterface<IsAmmGoodArgs, Boolean> = (message: IsAmmGoodArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Boolean>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Boolean>, callback?: grpc_1.requestCallback<Boolean>): grpc_1.ClientUnaryCall => {
            return super.IsAmmGood(message, metadata, options, callback);
        };
        GetMostActiveToken: GrpcUnaryServiceInterface<GetTokenByArgs, TokenBy> = (message: GetTokenByArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, callback?: grpc_1.requestCallback<TokenBy>): grpc_1.ClientUnaryCall => {
            return super.GetMostActiveToken(message, metadata, options, callback);
        };
        GetTokenByTrending: GrpcUnaryServiceInterface<GetTokenByArgs, TokenBy> = (message: GetTokenByArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, callback?: grpc_1.requestCallback<TokenBy>): grpc_1.ClientUnaryCall => {
            return super.GetTokenByTrending(message, metadata, options, callback);
        };
        GetTokenByBuy: GrpcUnaryServiceInterface<GetTokenByArgs, TokenBy> = (message: GetTokenByArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, callback?: grpc_1.requestCallback<TokenBy>): grpc_1.ClientUnaryCall => {
            return super.GetTokenByBuy(message, metadata, options, callback);
        };
        GetTokenBySell: GrpcUnaryServiceInterface<GetTokenByArgs, TokenBy> = (message: GetTokenByArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TokenBy>, callback?: grpc_1.requestCallback<TokenBy>): grpc_1.ClientUnaryCall => {
            return super.GetTokenBySell(message, metadata, options, callback);
        };
        GetWhaleCountByWindow: GrpcUnaryServiceInterface<GetWhaleCountByWindowArgs, WhaleCountByWindow> = (message: GetWhaleCountByWindowArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<WhaleCountByWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<WhaleCountByWindow>, callback?: grpc_1.requestCallback<WhaleCountByWindow>): grpc_1.ClientUnaryCall => {
            return super.GetWhaleCountByWindow(message, metadata, options, callback);
        };
        GetOneMinuteTradeSizeByWindow: GrpcUnaryServiceInterface<GetOneMinuteTradeSizeByWindowArgs, OneMinuteTradeSizeByWindow> = (message: GetOneMinuteTradeSizeByWindowArgs, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<OneMinuteTradeSizeByWindow>, options?: grpc_1.CallOptions | grpc_1.requestCallback<OneMinuteTradeSizeByWindow>, callback?: grpc_1.requestCallback<OneMinuteTradeSizeByWindow>): grpc_1.ClientUnaryCall => {
            return super.GetOneMinuteTradeSizeByWindow(message, metadata, options, callback);
        };
    }
}
